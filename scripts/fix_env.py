#!/usr/bin/env python3
"""
Fix and complete the .env file with all required variables for the local AI stack.
This script ensures all missing environment variables are populated with secure defaults.
"""

import os
import sys
import secrets
import string
from pathlib import Path

# Required environment variables that the stack expects
REQUIRED_VARS = {
    # Base configuration - will be overridden by deploy script
    'BASE_DOMAIN': 'localhost',
    'ACME_EMAIL': 'admin@localhost',
    'CLOUDFLARE_API_TOKEN': 'change_me_cf_token',
    
    # Supabase specific
    'SUPABASE_DB_PASSWORD': None,  # Will generate
    'SECRET_KEY_BASE': None,       # Will generate
    'VAULT_ENC_KEY': None,         # Will generate
    'LOGFLARE_PUBLIC_ACCESS_TOKEN': None,   # Will generate
    'LOGFLARE_PRIVATE_ACCESS_TOKEN': None,  # Will generate
    
    # Docker configuration
    'DOCKER_SOCKET_LOCATION': '/var/run/docker.sock',
    
    # Hostnames (will be derived from BASE_DOMAIN)
    'N8N_HOSTNAME': None,
    'FLOWISE_HOSTNAME': None,
    'WEBUI_HOSTNAME': None,
    'PORTAL_HOSTNAME': None,
    'SEARXNG_HOSTNAME': None,
    'SUPABASE_HOSTNAME': None,
    'LANGFUSE_HOSTNAME': None,
    'OLLAMA_HOSTNAME': None,
    'NEO4J_HOSTNAME': None,
    'TRAEFIK_DASHBOARD_HOST': None,
    'SUPABASE_STUDIO_HOSTNAME': None,
    'FUNCTIONS_HOSTNAME': None,
    'REALTIME_HOSTNAME': None,
}

def generate_secure_secret(length=32):
    """Generate a secure random string."""
    alphabet = string.ascii_letters + string.digits + "-_"
    return ''.join(secrets.choice(alphabet) for _ in range(length))

def generate_hex_secret(length=32):
    """Generate a secure hex string."""
    return secrets.token_hex(length)

def read_existing_env(env_path):
    """Read existing .env file and return as dict."""
    env_vars = {}
    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key] = value
    return env_vars

def write_env_file(env_path, env_vars):
    """Write environment variables to .env file."""
    with open(env_path, 'w') as f:
        f.write("############\n")
        f.write("# Complete environment file for local AI stack\n")
        f.write("# Generated by scripts/oneclick_deploy.sh\n")
        f.write("############\n\n")
        
        # Group variables by category
        base_config = ['BASE_DOMAIN', 'ACME_EMAIL', 'CLOUDFLARE_API_TOKEN']
        hostnames = [k for k in env_vars.keys() if k.endswith('_HOSTNAME') or k.endswith('_HOST')]
        db_supabase = [k for k in env_vars.keys() if 'POSTGRES' in k or 'SUPABASE' in k or 'JWT' in k or 'ANON' in k or 'SERVICE_ROLE' in k]
        app_secrets = [k for k in env_vars.keys() if any(word in k for word in ['PASSWORD', 'SECRET', 'KEY', 'TOKEN']) and not any(word in k for word in ['POSTGRES', 'JWT', 'ANON', 'SERVICE_ROLE', 'CLOUDFLARE'])]
        
        categories = {
            'Base Configuration': base_config,
            'Hostnames': hostnames,
            'Database & Supabase': db_supabase,
            'Application Secrets': app_secrets,
            'Other Configuration': [k for k in env_vars.keys() if k not in (base_config + hostnames + db_supabase + app_secrets)]
        }
        
        written_keys = set()
        for category, keys in categories.items():
            if keys:
                f.write(f"# {category}\n")
                for key in sorted(keys):
                    if key in env_vars and key not in written_keys:
                        f.write(f"{key}={env_vars[key]}\n")
                        written_keys.add(key)
                f.write("\n")
        
        # Write any remaining keys
        remaining = [k for k in sorted(env_vars.keys()) if k not in written_keys]
        if remaining:
            f.write("# Additional Variables\n")
            for key in remaining:
                f.write(f"{key}={env_vars[key]}\n")

def main():
    repo_root = Path(__file__).parent.parent
    env_path = repo_root / '.env'
    
    # Read domain and email from command line args or environment
    domain = sys.argv[1] if len(sys.argv) > 1 else os.environ.get('DEPLOY_DOMAIN', 'localhost')
    email = sys.argv[2] if len(sys.argv) > 2 else os.environ.get('DEPLOY_EMAIL', 'admin@localhost')
    
    print(f"Fixing environment file: {env_path}")
    print(f"Using domain: {domain}, email: {email}")
    
    # Read existing .env
    existing_vars = read_existing_env(env_path)
    print(f"Found {len(existing_vars)} existing variables")
    
    # Start with existing variables
    env_vars = existing_vars.copy()
    
    # Override base configuration
    env_vars['BASE_DOMAIN'] = domain
    env_vars['ACME_EMAIL'] = email
    
    # Add missing required variables
    missing_count = 0
    
    for var, default in REQUIRED_VARS.items():
        if var not in env_vars or not env_vars[var] or env_vars[var].startswith('change_me'):
            missing_count += 1
            
            if var == 'BASE_DOMAIN':
                env_vars[var] = domain
            elif var == 'ACME_EMAIL':
                env_vars[var] = email
            elif var.endswith('_HOSTNAME') or var.endswith('_HOST'):
                # Generate hostname based on service name
                service = var.replace('_HOSTNAME', '').replace('_HOST', '').lower()
                if service == 'traefik_dashboard':
                    service = 'traefik'
                elif service == 'supabase_studio':
                    service = 'studio'
                env_vars[var] = f"{service}.{domain}"
            elif 'SECRET' in var or 'KEY' in var or 'TOKEN' in var:
                if 'HEX' in var or var in ['VAULT_ENC_KEY', 'SECRET_KEY_BASE']:
                    env_vars[var] = generate_hex_secret(32)
                else:
                    env_vars[var] = generate_secure_secret(48)
            elif 'PASSWORD' in var:
                env_vars[var] = generate_secure_secret(24)
            elif default is not None:
                env_vars[var] = default
            else:
                env_vars[var] = generate_secure_secret(32)
    
    print(f"Added/updated {missing_count} variables")
    
    # Backup existing .env if it exists
    if env_path.exists():
        import datetime
        timestamp = datetime.datetime.now().strftime("%Y%m%dT%H%M%SZ")
        backup_path = env_path.with_suffix(f'.{timestamp}.bak')
        env_path.rename(backup_path)
        print(f"Backed up existing .env to {backup_path.name}")
    
    # Write the complete .env file
    write_env_file(env_path, env_vars)
    print(f"Generated complete .env file with {len(env_vars)} variables")
    
    # Set appropriate permissions
    os.chmod(env_path, 0o600)
    print("Set .env permissions to 600 (owner read/write only)")

if __name__ == '__main__':
    main()
